{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "72231626_18edd2e1",
        "filename": "stats/stats_log_api_gen/Collation.cpp",
        "patchSetId": 1
      },
      "lineNbr": 374,
      "author": {
        "id": 1286922
      },
      "writtenOn": "2023-01-04T03:33:03Z",
      "side": 1,
      "message": "How is the enum type name different from the field name?\n\n    Foo foo_state \u003d 1\n    \nWould we store `foo` or `foo_state`? If we store foo, and foo is reused in the same atom, we might have collisions.",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c1332e50_96c12c12",
        "filename": "stats/stats_log_api_gen/Collation.cpp",
        "patchSetId": 1
      },
      "lineNbr": 374,
      "author": {
        "id": 1827146
      },
      "writtenOn": "2023-01-04T04:35:23Z",
      "side": 1,
      "message": "Correct, here I am looking for a \"Foo\" to enable generation constant and typedef such as \u003cAtom\u003e_\u003cEnumType\u003e - `VendorAtom1_VendorAtom1Type`",
      "parentUuid": "72231626_18edd2e1",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec05b4ae_c16149d3",
        "filename": "stats/stats_log_api_gen/native_writer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1827146
      },
      "writtenOn": "2022-12-28T06:44:00Z",
      "side": 1,
      "message": "this code generates something like below\n```\nenum VendorAtom1_VendorAtom1Type : int {\n    VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_UNKNOWN \u003d 0,\n    VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_1 \u003d 1,\n    VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_2 \u003d 2,\n    VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_3 \u003d 3\n};\n\nclass VendorAtom1 final {\npublic:\n\n    typedef VendorAtom1_VendorAtom1Type VendorAtom1Type;\n    static constexpr VendorAtom1Type VENDOR_ATOM1_TYPE_UNKNOWN \u003d VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_UNKNOWN;\n    static constexpr VendorAtom1Type VENDOR_ATOM1_TYPE_1 \u003d VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_1;\n    static constexpr VendorAtom1Type VENDOR_ATOM1_TYPE_2 \u003d VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_2;\n    static constexpr VendorAtom1Type VENDOR_ATOM1_TYPE_3 \u003d VENDOR_ATOM1__VENDOR_ATOM1_TYPE__VENDOR_ATOM1_TYPE_3;\n\n};\n```\n\nIt replicates the approach by protoc for enums",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13d67163_bd02ed00",
        "filename": "stats/stats_log_api_gen/native_writer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1286922
      },
      "writtenOn": "2023-01-04T03:33:03Z",
      "side": 1,
      "message": "I\u0027ll defer to Muhammad for the review, but I have a couple of questions\n\n1. Code size - will it be a lot bigger? I know enums/classes in cpp are fairly lightweight\n2. Any chance of a conflict with other enums? The reason we have two underscores is to avoid collisions. What if the same atom has two enums, like below:\n\n\n    message AtomDef {\n        enum  Foo {\n            unknown \u003d 0;\n        }\n        Foo foo \u003d 1;\n        enum FooState {\n            unknown \u003d 2;\n        }\n        FooState foo_state \u003d 2;\n    }\n\nI believe the gen code for the class part would look like:\n    \n    class AtomDef final {\n    public:\n        typedef AtomDef_Foo Foo;\n        static constexpr Foo ATOM_DEF_UNKNOWN \u003d ATOM_DEF__FOO__UNKNOWN;\n        \n        typedef AtomDef_FooState FooState;\n        static constexpr FooState ATOM_DEF_UNKNOWN \u003d ATOM_DEF__FOO_STATE__UNKNOWN;\n    };\n    \nWhich would result in a collision. cpp protos would likely have the same issue, so maybe it is not a big deal, but this was the reasoning behind the double underscore approach.\n\n3. This will result in the vendor code being inconsistent with the platform code stylistically. That might be worth the tradeoff for an easier migration, but I did want to note it.",
      "parentUuid": "ec05b4ae_c16149d3",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d36a8478_85a95f11",
        "filename": "stats/stats_log_api_gen/native_writer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1827146
      },
      "writtenOn": "2023-01-04T04:35:23Z",
      "side": 1,
      "message": "The example here is invalid protobuf definition which will lead to protoc compile time error on the first place\n\nThe failure is expected behavior - see https://github.com/protocolbuffers/protobuf/issues/5425\n\nSee more here http://b/263825707#comment4",
      "parentUuid": "13d67163_bd02ed00",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8a1a103_26fc5077",
        "filename": "stats/stats_log_api_gen/native_writer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 581,
      "author": {
        "id": 1286922
      },
      "writtenOn": "2023-01-04T03:33:03Z",
      "side": 1,
      "message": "This inner for loop is almost identical to write_native_atom_enums. I have a preference to keep things consistent and reuse the code for the enum/int generation if reasonable. We could still build the classes on top of that.",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d77f9b60_e2e61d24",
        "filename": "stats/stats_log_api_gen/native_writer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 581,
      "author": {
        "id": 1827146
      },
      "writtenOn": "2023-01-04T20:15:37Z",
      "side": 1,
      "message": "there are some significant discrepancy in multiple places - to make the function `` more general below is the change - which seems too much compared to introduced code duplication at this stage:\n```\nstring default_prolog_func(const shared_ptr\u003cAtomDecl\u003e\u0026 atomDecl, const AtomField\u0026 field) {\n    return \"// Values for \" + atomDecl-\u003emessage + \".\" + field.name;\n}\n\nstring default_const_name_func(const shared_ptr\u003cAtomDecl\u003e\u0026 atomDecl, const AtomField\u0026 field,\n                               const std::pair\u003cint, string\u003e\u0026 enumValue) {\n    string constNameDef \u003d \"const int32_t \";\n    constNameDef +\u003d make_constant_name(atomDecl-\u003emessage);\n    constNameDef +\u003d \"__\";\n    constNameDef +\u003d make_constant_name(field.name);\n    constNameDef +\u003d \"__\";\n    constNameDef +\u003d make_constant_name(enumValue.second);\n\n    return constNameDef;\n}\n\nstring default_line_end_func(bool /*isLast*/) {\n    return \";\";\n}\n\nvoid write_native_atom_enums(FILE* out, const Atoms\u0026 atoms, atom_enums_prolog_func prolog_func,\n                             const_name_func name_func, line_eng_func line_end_func,\n                             bool skip_duplicate_enum_type) {\n    // Print constants for the enum values.\n    fprintf(out, \"//\\n\");\n    fprintf(out, \"// Constants for enum values\\n\");\n    fprintf(out, \"//\\n\\n\");\n    for (AtomDeclSet::const_iterator atomIt \u003d atoms.decls.begin(); atomIt !\u003d atoms.decls.end();\n         atomIt++) {\n        set\u003cstring\u003e processedEnums;\n        for (vector\u003cAtomField\u003e::const_iterator field \u003d (*atomIt)-\u003efields.begin();\n             field !\u003d (*atomIt)-\u003efields.end(); field++) {\n            if (field-\u003ejavaType \u003d\u003d JAVA_TYPE_ENUM || field-\u003ejavaType \u003d\u003d JAVA_TYPE_ENUM_ARRAY) {\n                // there might be N fields with the same enum type\n                // avoid duplication definitions\n                if (skip_duplicate_enum_type \u0026\u0026\n                    processedEnums.find(field-\u003eenumTypeName) !\u003d processedEnums.end()) {\n                    continue;\n                }\n                processedEnums.insert(field-\u003eenumTypeName);\n\n                fprintf(out, \"%s\\n\", prolog_func(*atomIt, *field).c_str());\n                size_t i \u003d 0;\n                for (map\u003cint, string\u003e::const_iterator value \u003d field-\u003eenumValues.begin();\n                     value !\u003d field-\u003eenumValues.end(); value++, i++) {\n                    fprintf(out, \"%s \u003d %d%s\\n\", name_func(*atomIt, *field, *value).c_str(),\n                            value-\u003efirst, line_end_func(i \u003d\u003d field-\u003eenumValues.size() - 1).c_str());\n                }\n                fprintf(out, \"\\n\");\n            }\n        }\n    }\n}\n```\n\nthe updated version of `write_native_atom_enums` could be used for vendor atoms in next way:\n```\nstring vendor_enum_prolog_func(const shared_ptr\u003cAtomDecl\u003e\u0026 atomDecl, const AtomField\u0026 field) {\n    return \"\\nenum \" + atomDecl-\u003emessage + \"_\" + field.enumTypeName + \" : int {\\n\";\n}\n\nstring vendor_const_name_func(const shared_ptr\u003cAtomDecl\u003e\u0026 atomDecl, const AtomField\u0026 field,\n                              const std::pair\u003cint, string\u003e\u0026 enumValue) {\n    string constNameDef \u003d \"    \" + make_constant_name(atomDecl-\u003emessage);\n    constNameDef +\u003d \"__\";\n    constNameDef +\u003d make_constant_name(field.enumTypeName);\n    constNameDef +\u003d \"__\";\n    constNameDef +\u003d make_constant_name(enumValue.second);\n\n    return constNameDef;\n}\n\nstring vendor_enum_line_end_func(bool isLast) {\n    return isLast ? \"\\n};\" : \",\";\n}\n\n...\n    write_native_atom_enums(out, atoms, vendor_enum_prolog_func, vendor_const_name_func,\n                            vendor_enum_line_end_func, true);\n\n```\n\nalternative is to define a class with member functions for print the code, and one more inherited class where required member functions would be overridden\n\nThis is semantically the same approach - may be easier to read\n\nwdyt?",
      "parentUuid": "d8a1a103_26fc5077",
      "revId": "695285293ac77a6694c2a99349611192df900bd5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}