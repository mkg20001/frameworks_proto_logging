{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5dbb9691_790fea71",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-17T20:05:46Z",
      "side": 1,
      "message": "What is the best way to test this?  I described what I did in the test stanzas but something more complete would be nice.\n\nAlso, I\u0027m not sure whether I need to handle the Q API.",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7faf92b_9b7fa8be",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-02-19T21:29:18Z",
      "side": 1,
      "message": "Is this needed to log a specific atom to statsd? I\u0027m not familiar with Rust and your use case in particular here. Can you schedule a time to meet during Android Metrics Client Office Hours (go/amc-oh) so we can better understand your use case? Thanks",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ee064a5_b47b9727",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-19T21:31:03Z",
      "side": 1,
      "message": "Rust programs in general will presumably want to log things, and so to support all possible atoms we implemented a Rust backend.",
      "parentUuid": "b7faf92b_9b7fa8be",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b5e17e9a_9b146242",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-22T17:19:56Z",
      "side": 1,
      "message": "Some relevant samples of the generated Rust code are at https://paste.googleplex.com/4642731377819648.",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed1fe5ac_92a4258c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-22T22:32:23Z",
      "side": 1,
      "message": "Friendly ping.\n\nThe office hours are full this week, but I don\u0027t think we need to delay this CL for two weeks for them.  For code written in Rust to be able to use this library, we need a Rust interface such as this.",
      "parentUuid": "8ee064a5_b47b9727",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6cd5161_3052aeaf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-02-23T20:25:09Z",
      "side": 1,
      "message": "I\u0027ve set up a meeting for tomorrow. Our main concerns are related to maintenance and to better understand how Rust programs will log to statsd.\n\nIt seems like we\u0027re depending on C++ generated code. Generated Rust code is calling generated C++ code. Ideally, we\u0027d want generated Rust code to use libstatspush and libstatspull directly like C++ generated code does.",
      "parentUuid": "ed1fe5ac_92a4258c",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2b12e98_50c677bc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-23T20:35:58Z",
      "side": 1,
      "message": "I don\u0027t think we\u0027re depending on generated C++ code?  The Rust code directly calls into libstats* just like the C++ code.\n\nAnd I assume that Rust programs will log to statsd the same way C++ programs do, i.e., they\u0027ll log whatever data they have.  Or did you mean something else?",
      "parentUuid": "f6cd5161_3052aeaf",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6be29d36_b8a43d83",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-02-24T19:32:28Z",
      "side": 1,
      "message": "I guess I\u0027m confused about why libstatslog is a dependency for libstatslog_bindgen since libstatslog already consists of generated code.",
      "parentUuid": "a2b12e98_50c677bc",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2078cb42_60cd1c7d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-24T19:42:50Z",
      "side": 1,
      "message": "Bindgen simply generate Rust bindings for a C interface; it doesn\u0027t generate any code at all.  The generated file this produces simple contains the relevant function and constant definitions but no Rust executable code at all.\n\nIf I remember this case correctly, I didn\u0027t actually need the library dependency for the code, but I needed a way to add the proper include directory, which adding it as a dependence did.",
      "parentUuid": "6be29d36_b8a43d83",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f623cc03_a9ed433b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-24T23:59:59Z",
      "side": 1,
      "message": "Okay, as we discussed earlier, I removed the entire dependence and use of libstatslog and instead modified the writer to generate the enums, constants, and annotations.  Thanks for suggesting that!\n\nFun fact: I spent the most time trying to get the comments to look right. \u003d)",
      "parentUuid": "2078cb42_60cd1c7d",
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff47e3f6_87993265",
        "filename": "stats/stats_log_api_gen/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 183,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-02-23T20:25:09Z",
      "side": 1,
      "message": "FYI, not all atoms are logged from libstatslog. For example lmkd related atoms use libstatslog_lmkd:\nhttps://source.corp.google.com/android/system/memory/lmkd/Android.bp;rcl\u003d1bce47b66fe9246def651cbe856f89264859f83a;l\u003d75\n\nFor atoms that are currently being logged using libstatslog, this is fine. For atoms that are not logged using libstatslog, we probably don\u0027t want to log them through libstatslog when logging from Rust programs.",
      "range": {
        "startLine": 183,
        "startChar": 9,
        "endLine": 183,
        "endChar": 20
      },
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18e75d0a_f77aecce",
        "filename": "stats/stats_log_api_gen/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 183,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-23T20:35:58Z",
      "side": 1,
      "message": "Hmm, I don\u0027t see any mention of lmkd in the generated C++ code.  How does it handle that case?  I tried to mirror its approach as much as possible.",
      "parentUuid": "ff47e3f6_87993265",
      "range": {
        "startLine": 183,
        "startChar": 9,
        "endLine": 183,
        "endChar": 20
      },
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32e7f148_cfb75139",
        "filename": "stats/stats_log_api_gen/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 183,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-02-24T19:32:28Z",
      "side": 1,
      "message": "The atom names themselves aren\u0027t mentioned in the generated code. You\u0027ll notice, the generated method names and method parameter names are all generic: arg1, arg2, etc. This is because a stats_write method could be used for logging multiple atoms if they have the same field types.\n\nLMKD doesn\u0027t use this generated statslog.h/cpp here. They specify which atoms they care about by adding a \"module\" annotation in the atoms.proto file. In the LMKD build file at system/memory/lmkd/Android.bp, there\u0027s a separate genrule which invokes stats-log-api-gen with the given \"module\" annotation parameter. This generates a separate source file with stats_write methods for only the atoms that have the annotation.",
      "parentUuid": "18e75d0a_f77aecce",
      "range": {
        "startLine": 183,
        "startChar": 9,
        "endLine": 183,
        "endChar": 20
      },
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a2ac5a2_eaf8d596",
        "filename": "stats/stats_log_api_gen/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 183,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-02-24T19:42:50Z",
      "side": 1,
      "message": "The Rust API doesn\u0027t use overloaded stats_write methods: it generates one such method for each atom.  This makes the Rust compiler happy but also seems easier for users, since e.g., IDEs can suggest the exact parameters needed.\n\nI didn\u0027t explicitly support individual modules, but from looking at the code it seems like that\u0027s handled by the Collator and so the individual writers should get it for free.  I don\u0027t handle adding an import header, but that seems like it would be simple to add if necessary (basically just add a \"use\" statement just like the C++ version adds an #include, I assume).",
      "parentUuid": "32e7f148_cfb75139",
      "range": {
        "startLine": 183,
        "startChar": 9,
        "endLine": 183,
        "endChar": 20
      },
      "revId": "932986f4d5ba70de78031d615f5bfed6a5c7749d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}