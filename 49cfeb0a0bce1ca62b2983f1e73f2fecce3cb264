{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2e688581_bc491783",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-12-21T18:59:54Z",
      "side": 1,
      "message": "Joel, can you please take a look?\nIf I understand correctly, we\u0027re using statslog.rs from com.android.virt APEX. We have to be careful because APEXes can be deployed outside dessert release cycle and can be installed on devices running older platform versions. Once com.android.virt \n APEX goes out in T, we can add new logging functionality for U, that\u0027s not compatible with T. A new version of com.android.virt APEX containing new logging functionality we add in U or later will cause problems when installed on T devices. \n\nWe\u0027ve solved this for C++/Java logging by generating a separate statslog file that only contains atoms that are logged from the given apex.\nExample: https://source.corp.google.com/android/packages/modules/DnsResolver/Android.bp?q\u003dstatslog_resolv.h\nWe pass min api version that we need to support to generate compatibility code and only generate log methods for atoms we care about through the module annotation.\n\nWe will need to do something similar for Rust logging. It would be nice if we could generate a separate statslog.rs file that only contains VmCreationRequested atom.",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2389c0d1_0d1e17e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-12-21T19:04:45Z",
      "side": 1,
      "message": "See https://android-review.googlesource.com/c/platform/system/core/+/1658885/comment/9ac2cba1_2b88170b/ for both some instructions on how to do this and arguments for why it is a bad idea.",
      "parentUuid": "2e688581_bc491783",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce3651ab_535ec080",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-12-21T19:06:55Z",
      "side": 1,
      "message": "Also see https://android-review.googlesource.com/c/platform/frameworks/proto_logging/+/1592771/comment/ff47e3f6_87993265/ for more detailed instructions.",
      "parentUuid": "2389c0d1_0d1e17e7",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b616ec7_83148a7a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-12-22T01:39:18Z",
      "side": 1,
      "message": "We still need a way to customize generated code based on platform version. The earlier discussions were from memory usage standpoint. If in the future, we ship code to Android T that uses Android U+ API, it can break the device. This is not needed right now but will be required if we make logging changes after T for backwards compatibility.",
      "parentUuid": "ce3651ab_535ec080",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69cad194_562a6a03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-12-22T01:41:41Z",
      "side": 1,
      "message": "Doesn\u0027t the comment I linked address this?",
      "parentUuid": "1b616ec7_83148a7a",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9fc72a7_4db9149a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-12-22T03:25:26Z",
      "side": 1,
      "message": "Reading the 2nd link, it seems like we can generate logging code for just VmCreationRequested atom by passing --module virtualizationservice in stats-log-api-gen params. But to do that, it seems like we need to:\n\n1. add a genrule in virtualizationservice/Android.bp for statslog_virtualizationservice.rs similar to statslog.rs in stats_log_api_gen/Android.bp. We just pass --module virtualizationservice --minApiLevel 34 as additional params to stats-log-api-gen.\n\n2. repeat #1 for statslog_virtualizationservice_header.rs\n\n3. Add rust_virtualizationservice_header_wrapper.rs in virtualizationservice/ that looks like stats_log_api_gen/rust_header_wrapper.rs\n\n4. repeat #3 for rust_virtualizationservice_wrapper.rs\n\n5. Add a rust_library build rule for libstatslog_virtualizationservice_rust_header in virtualizationservice/Android.bp similar to libstatslog_rust_header rule in stats_log_api_gen/Android.bp\n\n6. repeat #5 for libstatslog_virtualizationservice_rust\n\nDoes that sound right?\n\nWe don\u0027t have to do this right now but if we change code generation logic post T that\u0027s not backwards compatible, we\u0027ll need to do this change then and generate compatibility code specifically for logging VmCreationRequested atom. IMO it\u0027s harder to remember to make these client side changes later.",
      "parentUuid": "69cad194_562a6a03",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9c28220_1dbc0014",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-12-22T04:06:04Z",
      "side": 1,
      "message": "I agree that steps 1, 2, 5, and 6 are likely needed and I believe correspond directly to the similar C++ rules.\n\nSteps 3 and 4 presumably mirror the current Rust implementation, but due to recent changes to the Rust build system they are likely no longer required.  See ag/16434085 for a similar example.  So they\u0027re hopefully not required and could be removed as a cleanup step.\n\nAssuming we can remove steps 3 and 4, the steps for Rust are quite similar to the steps for C++, right?  (And even if 3 and 4 are required, they\u0027re hopefully relatively minor boilerplate and so not too painful.)\n\n+Matt as an FYI and in case he has any comments since he commented on one of the linked threads.",
      "parentUuid": "a9fc72a7_4db9149a",
      "revId": "49cfeb0a0bce1ca62b2983f1e73f2fecce3cb264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}